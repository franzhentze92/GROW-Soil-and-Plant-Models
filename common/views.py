from django.shortcuts import render
from django.http import HttpResponseRedirect
from urllib.parse import urlencode, urlparse, parse_qs, urlunparse
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
from functools import wraps
from bs4 import BeautifulSoup

import json
import requests

USER_URL_DOMAIN = 'https://gestion.ntsgrow.com'
AGRONOMY_URL_DOMAIN = 'https://agronomy.ntsgrow.com'

USER_VALIDATION_URL = f'{USER_URL_DOMAIN}/api/crops/farm-management/token-to-user'
AGRONOMY_VALIDATION_URL = f'{AGRONOMY_URL_DOMAIN}/api/crops/farm-management/token-to-user'

# TOKEN0 = '249|kMvF8qkP36TKRLoSkoL0bIrYgeC4L3vhcmgLIE3zbfa6633d'
# TOKEN1 = '77|sfQscMs05FBzUDcTLXxad8p574sg6R65FphA6SZL34eb2921'

def is_allowed_path(path, ALLOWED_PATHS):
    # Allow if:
    # - path is exactly in ALLOWED_PATHS
    # - path starts with any allowed path + '/'
    return any(
        path == allowed or path.startswith(allowed + '/')
        for allowed in ALLOWED_PATHS
    )

def check_specific_path_condition(path, SPECIFIC_PATHS_CONDITIONS):
    for expected_path, condition in SPECIFIC_PATHS_CONDITIONS:
        if (path.startswith(expected_path + '/')) and condition:
            return False 
    return True

def set_cookie_redirect(request):
    """
    The behaviour that this function is replacing is that instead of authenticating the user 
    through the "gestion" platform, we get the Auth token generated by the platform from the 
    cookies, and use it to authenticate the user in the gestion API.

    This function sets a token in the URL which will added to the browser cookies for later use.
    """
    # Get the role, we wil login to the specified role platform, and get the token from the response url
    role    = request.GET.get('role', 'user')

    if role not in ['user', 'agronomist']:
        return render(
            request,
            "unauthorized.html",
            {"message": "Unauthorized role. Please specify a valid role."}
        )

    # Based on the role, send a login request to the appropriate platform
    login_url       = None
    referer         = f'/?role={role}'
    token           = None

    if role == 'user':
        # For user, we use the USER_URL_DOMAIN
        login_url = f'{USER_URL_DOMAIN}/login'
    elif role == 'agronomist':
        # For agronomist, we use the AGRONOMY_URL_DOMAIN
        login_url = f'{AGRONOMY_URL_DOMAIN}/login'

    # Formulate the request to the login URL
    CREDENTIALS = {
        'user': {
            'email': 'bitnami222@mail.com', 
            'password': 'bitnami222'   
        },
        'agronomist': {
            'email': 'admin@admin.com',
            'password': 'admin@admin.com'
        }
    }

    credentials = CREDENTIALS.get(role)
    
    try:    
        session = requests.Session()

        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'
        }

        # Step 1: GET the login page to retrieve CSRF token
        response = session.get(login_url, headers=headers)
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_token = soup.find('input', {'name': '_token'})['value']

        # Step 2: POST login form with token and credentials
        payload = {
            '_token': csrf_token,
            'email': credentials['email'],
            'password': credentials['password'],
        }
        # Make the POST request to login
        post_response = session.post(login_url, data=payload, headers=headers)

        # Parse the URL
        parsed_url = urlparse(post_response.url)

        # Extract query parameters
        query_params = parse_qs(parsed_url.query)

        # Get the token value
        token = query_params.get('token', [None])[0]

        if not token:
            return JsonResponse({'error': 'Token not found in the response URL'}, status=400)

    except requests.exceptions.RequestException as e:
        # Handle errors that happen while making the request
        return JsonResponse({'error': 'Failed to authenticate user'}, status=500)    

    # Parse referer URL and add the token as a query parameter
    parsed_url = urlparse(referer)
    query_params = parse_qs(parsed_url.query)
    query_params['token'] = token
    new_query = urlencode(query_params, doseq=True)
    new_url = urlunparse(parsed_url._replace(query=new_query))

    # Create response with a cookie
    response = HttpResponseRedirect(new_url)

    # Redirect to the referer URL with the token as a query parameter
    return response

@csrf_exempt
def list_paddocks(request):
    """
    Get all of the user-created paddocks from the gestion API. 
    The endpoint requires a token to be passed in the header.
    Note that the endpoint returns the farms, paddocks, maps, and users data.
    """
    if request.method == 'POST':
        try:
            # Parse the request body to get the token
            body_unicode = request.body.decode('utf-8')
            body_data = json.loads(body_unicode)
            token = body_data.get('token')

            if not token:
                return JsonResponse({'error': 'Token not provided'}, status=400)
            
            # Construct the URL for listing paddocks
            url = f'{USER_URL_DOMAIN}/api/crops/farm-management/list-paddocks'

            # Set the headers for the request
            headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }

            # Set the payload for the request
            payload = {
                'id': 'All'
            }

            # Make the GET request to the external API
            response = requests.get(url, headers=headers, json=payload)
            response.raise_for_status()  # Raise an error for bad responses
            data = response.json()

            # Return the data fetched from the external API
            return JsonResponse(data)

        except Exception as e: 
            # Handle errors that happen while making the external request
            return JsonResponse({'error': 'Failed to fetch paddocks from external API'}, status=500)

    return JsonResponse({'error': 'Invalid HTTP method'}, status=405)

@csrf_exempt
def list_farms(request):
    """
    Get all of the user-created farms from the gestion API. 
    The endpoint requires a token to be passed in the header.
    Note that the endpoint returns the farms and users data.
    """
    if request.method == 'POST':
        try:
            # Parse the request body to get the token
            body_unicode = request.body.decode('utf-8')
            body_data = json.loads(body_unicode)
            token = body_data.get('token')

            if not token:
                return JsonResponse({'error': 'Token not provided'}, status=400)
            
            # Construct the URL for listing paddocks
            url = f'{USER_URL_DOMAIN}/api/crops/farm-management/list-farms'

            # Set the headers for the request
            headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }

            # Make the GET request to the external API
            response = requests.get(url, headers=headers)
            response.raise_for_status()  # Raise an error for bad responses
            data = response.json()

            # Return the data fetched from the external API
            return JsonResponse(data)

        except Exception as e: 
            # Handle errors that happen while making the external request
            return JsonResponse({'error': 'Failed to fetch paddocks from external API'}, status=500)

    return JsonResponse({'error': 'Invalid HTTP method'}, status=405)

@csrf_exempt
def token_to_user(request):
    """
    Get the user information from the gestion API using the token.
    """
    if request.method == 'POST':
        try:
            # Parse the request body to get the token
            body_unicode = request.body.decode('utf-8')
            body_data = json.loads(body_unicode)
            token = body_data.get('token')
            role = body_data.get('role', 'user')

            if not token:
                return JsonResponse({'error': 'Token not provided'}, status=400)
            
            # Construct the URL for listing paddocks
            url = None 
            
            if role == 'user':
                url = USER_VALIDATION_URL
            elif role == 'agronomist':
                url = AGRONOMY_VALIDATION_URL

            # Set the headers for the request
            headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
            }

            # Make the GET request to the external API
            response = requests.get(url, headers=headers)
            response.raise_for_status()  # Raise an error for bad responses
            data = response.json()

            # Return the data fetched from the external API
            return JsonResponse(data)

        except Exception as e: 
            # Handle errors that happen while making the external request
            return JsonResponse({'error': 'Failed to fetch paddocks from external API'}, status=500)

    return JsonResponse({'error': 'Invalid HTTP method'}, status=405)

def validate_token(view_func):
    @wraps(view_func)
    def _wrapped_view(request, *args, **kwargs):
        role = request.GET.get('role')
        
        # Set default role to 'agronomist' if no role is provided
        if not role:
            role = 'agronomist'

        if role not in ['user', 'agronomist']:
            return render(
                request,
                "unauthorized.html",
                {"message": "Unauthorized role. Please specify a valid role."}
            )
        
        # Get the token from the request
        token = request.GET.get('token')

        if not token:
            # If no token is provided, redirect to get authenticated
            from django.shortcuts import redirect
            return redirect(f'/api/set-cookie/?role={role}')

        headers = {
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
        }

        try:
            # Validate the token based on the role
            response = None

            if role == 'user':
                ALLOWED_PATHS = [
                    '/',
                    '/plant-analysis',
                    '/soil-analysis',
                    '/analysis-submissions',
                    '/analysis-analytics',
                ]
                
                SPECIFIC_PATHS_CONDITIONS = [
                    ('/analysis-submissions', request.GET.get('type') == 'plant_report'),
                ]
                
                # Check if the request path is allowed for agronomists
                if not is_allowed_path(request.path, ALLOWED_PATHS) or not check_specific_path_condition(request.path, SPECIFIC_PATHS_CONDITIONS):
                    return render(
                        request,
                        "unauthorized.html",
                        {"message": "Unauthorized access to this page."}
                    )

                response = requests.get(USER_VALIDATION_URL, headers=headers)
            elif role == 'agronomist':
                # Agronomist is allowed to access certain paths only
                ALLOWED_PATHS = [
                    '/',
                    '/report-generation',
                    '/plant-analysis',
                    '/soil-analysis',
                    '/analysis-submissions'
                ]

                SPECIFIC_PATHS_CONDITIONS = [
                    ('/analysis-submissions', request.GET.get('type') != 'plant_report')
                ]

                # Check if the request path is allowed for agronomists
                if not is_allowed_path(request.path, ALLOWED_PATHS) or not check_specific_path_condition(request.path, SPECIFIC_PATHS_CONDITIONS):
                    return render(
                        request,
                        "unauthorized.html",
                        {"message": "Unauthorized access to this page."}
                    )

                response = requests.get(AGRONOMY_VALIDATION_URL, headers=headers)

            response.raise_for_status()
            request.user_data = response.json()  # Optional: use in view
        except requests.exceptions.HTTPError:
            return render(
                request,
                "unauthorized.html",
                {"message": "Unauthorized access. Invalid token."}
            )
        except Exception as e:
            return render(
                request,
                "unauthorized.html",
                {"message": "Failed to validate token. Exception occurred: " + str(e) + "."}
            )

        # If role is not 'user', skip validation
        return view_func(request, *args, **kwargs)

    return _wrapped_view